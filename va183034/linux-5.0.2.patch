diff -ruN linux-5.0.2a/arch/arm/boot/dts/Makefile linux-5.0.2b/arch/arm/boot/dts/Makefile
--- linux-5.0.2a/arch/arm/boot/dts/Makefile	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/arch/arm/boot/dts/Makefile	2020-09-18 07:39:01.466304000 -0700
@@ -1147,6 +1147,7 @@
 dtb-$(CONFIG_ARCH_VEXPRESS) += \
 	vexpress-v2p-ca5s.dtb \
 	vexpress-v2p-ca9.dtb \
+	vexpress-v2p-pds03.dtb \
 	vexpress-v2p-ca15-tc1.dtb \
 	vexpress-v2p-ca15_a7.dtb
 dtb-$(CONFIG_ARCH_VIRT) += \
diff -ruN linux-5.0.2a/arch/arm/boot/dts/vexpress-v2m-pds03.dtsi linux-5.0.2b/arch/arm/boot/dts/vexpress-v2m-pds03.dtsi
--- linux-5.0.2a/arch/arm/boot/dts/vexpress-v2m-pds03.dtsi	1969-12-31 16:00:00.000000000 -0800
+++ linux-5.0.2b/arch/arm/boot/dts/vexpress-v2m-pds03.dtsi	2020-09-18 15:56:50.668580280 -0700
@@ -0,0 +1,464 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * Motherboard Express uATX
+ * V2M-P1
+ *
+ * HBI-0190D
+ *
+ * Original memory map ("Legacy memory map" in the board's
+ * Technical Reference Manual)
+ *
+ * WARNING! The hardware described in this file is independent from the
+ * RS1 variant (vexpress-v2m-rs1.dtsi), but there is a strong
+ * correspondence between the two configurations.
+ *
+ * TAKE CARE WHEN MAINTAINING THIS FILE TO PROPAGATE ANY RELEVANT
+ * CHANGES TO vexpress-v2m-rs1.dtsi!
+ */
+
+/ {
+	smb@4000000 {
+		motherboard {
+			model = "V2M-P1";
+			arm,hbi = <0x190>;
+			arm,vexpress,site = <0>;
+			compatible = "arm,vexpress,v2m-p1", "simple-bus";
+			#address-cells = <2>; /* SMB chipselect number and offset */
+			#size-cells = <1>;
+			#interrupt-cells = <1>;
+			ranges;
+
+			flash@0,00000000 {
+				compatible = "arm,vexpress-flash", "cfi-flash";
+				reg = <0 0x00000000 0x04000000>,
+				      <1 0x00000000 0x04000000>;
+				bank-width = <4>;
+			};
+
+			psram@2,00000000 {
+				compatible = "arm,vexpress-psram", "mtd-ram";
+				reg = <2 0x00000000 0x02000000>;
+				bank-width = <4>;
+			};
+
+			ethernet@3,02000000 {
+				compatible = "smsc,lan9118", "smsc,lan9115";
+				reg = <3 0x02000000 0x10000>;
+				interrupts = <15>;
+				phy-mode = "mii";
+				reg-io-width = <4>;
+				smsc,irq-active-high;
+				smsc,irq-push-pull;
+				vdd33a-supply = <&v2m_fixed_3v3>;
+				vddvario-supply = <&v2m_fixed_3v3>;
+			};
+
+			usb@3,03000000 {
+				compatible = "nxp,usb-isp1761";
+				reg = <3 0x03000000 0x20000>;
+				interrupts = <16>;
+				port1-otg;
+			};
+
+			iofpga@7,00000000 {
+				compatible = "simple-bus";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 7 0 0x20000>;
+
+				v2m_sysreg: sysreg@0 {
+					compatible = "arm,vexpress-sysreg";
+					reg = <0x00000 0x1000>;
+					#address-cells = <1>;
+					#size-cells = <1>;
+					ranges = <0 0 0x1000>;
+
+					v2m_led_gpios: gpio@8 {
+						compatible = "arm,vexpress-sysreg,sys_led";
+						reg = <0x008 4>;
+						gpio-controller;
+						#gpio-cells = <2>;
+					};
+
+					v2m_mmc_gpios: gpio@48 {
+						compatible = "arm,vexpress-sysreg,sys_mci";
+						reg = <0x048 4>;
+						gpio-controller;
+						#gpio-cells = <2>;
+					};
+
+					v2m_flash_gpios: gpio@4c {
+						compatible = "arm,vexpress-sysreg,sys_flash";
+						reg = <0x04c 4>;
+						gpio-controller;
+						#gpio-cells = <2>;
+					};
+				};
+
+				v2m_sysctl: sysctl@1000 {
+					compatible = "arm,sp810", "arm,primecell";
+					reg = <0x01000 0x1000>;
+					clocks = <&v2m_refclk32khz>, <&v2m_refclk1mhz>, <&smbclk>;
+					clock-names = "refclk", "timclk", "apb_pclk";
+					#clock-cells = <1>;
+					clock-output-names = "timerclken0", "timerclken1", "timerclken2", "timerclken3";
+					assigned-clocks = <&v2m_sysctl 0>, <&v2m_sysctl 1>, <&v2m_sysctl 3>, <&v2m_sysctl 3>;
+					assigned-clock-parents = <&v2m_refclk1mhz>, <&v2m_refclk1mhz>, <&v2m_refclk1mhz>, <&v2m_refclk1mhz>;
+				};
+
+				/* PCI-E I2C bus */
+				v2m_i2c_pcie: i2c@2000 {
+					compatible = "arm,versatile-i2c";
+					reg = <0x02000 0x1000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					pcie-switch@60 {
+						compatible = "idt,89hpes32h8";
+						reg = <0x60>;
+					};
+				};
+
+				aaci@4000 {
+					compatible = "arm,pl041", "arm,primecell";
+					reg = <0x04000 0x1000>;
+					interrupts = <11>;
+					clocks = <&smbclk>;
+					clock-names = "apb_pclk";
+				};
+
+				mmci@5000 {
+					compatible = "arm,pl180", "arm,primecell";
+					reg = <0x05000 0x1000>;
+					interrupts = <9 10>;
+					cd-gpios = <&v2m_mmc_gpios 0 0>;
+					wp-gpios = <&v2m_mmc_gpios 1 0>;
+					max-frequency = <12000000>;
+					vmmc-supply = <&v2m_fixed_3v3>;
+					clocks = <&v2m_clk24mhz>, <&smbclk>;
+					clock-names = "mclk", "apb_pclk";
+				};
+
+				kmi@6000 {
+					compatible = "arm,pl050", "arm,primecell";
+					reg = <0x06000 0x1000>;
+					interrupts = <12>;
+					clocks = <&v2m_clk24mhz>, <&smbclk>;
+					clock-names = "KMIREFCLK", "apb_pclk";
+				};
+
+				kmi@7000 {
+					compatible = "arm,pl050", "arm,primecell";
+					reg = <0x07000 0x1000>;
+					interrupts = <13>;
+					clocks = <&v2m_clk24mhz>, <&smbclk>;
+					clock-names = "KMIREFCLK", "apb_pclk";
+				};
+
+				v2m_serial0: uart@e000 {
+					compatible = "arm,pl011", "arm,primecell";
+					reg = <0x0e000 0x1000>;
+					interrupts = <5>;
+					clocks = <&v2m_oscclk2>, <&smbclk>;
+					clock-names = "uartclk", "apb_pclk";
+				};
+
+				v2m_serial1: uart@a000 {
+					compatible = "arm,pl011", "arm,primecell";
+					reg = <0x0a000 0x1000>;
+					interrupts = <6>;
+					clocks = <&v2m_oscclk2>, <&smbclk>;
+					clock-names = "uartclk", "apb_pclk";
+				};
+
+				v2m_serial2: uart@b000 {
+					compatible = "arm,pl011", "arm,primecell";
+					reg = <0x0b000 0x1000>;
+					interrupts = <7>;
+					clocks = <&v2m_oscclk2>, <&smbclk>;
+					clock-names = "uartclk", "apb_pclk";
+				};
+
+				v2m_serial3: uart@c000 {
+					compatible = "arm,pl011", "arm,primecell";
+					reg = <0x0c000 0x1000>;
+					interrupts = <8>;
+					clocks = <&v2m_oscclk2>, <&smbclk>;
+					clock-names = "uartclk", "apb_pclk";
+				};
+
+				wdt@f000 {
+					compatible = "arm,sp805", "arm,primecell";
+					reg = <0x0f000 0x1000>;
+					interrupts = <0>;
+					clocks = <&v2m_refclk32khz>, <&smbclk>;
+					clock-names = "wdogclk", "apb_pclk";
+				};
+				
+				pds03_mmsensor@18000 {
+					compatible = "pds03,mmsensor";
+					reg = <0x18000 0x1000>;
+					interrupts = <27>;
+				};
+				
+				pds03_i2c: i2c@8000 {
+					compatible = "arm,versatile-i2c";
+					reg = <0x08000 0x1000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+				};
+
+				v2m_timer01: timer@15000 {
+					compatible = "arm,sp804", "arm,primecell";
+					reg = <0x15000 0x1000>;
+					interrupts = <2>;
+					clocks = <&v2m_sysctl 0>, <&v2m_sysctl 1>, <&smbclk>;
+					clock-names = "timclken1", "timclken2", "apb_pclk";
+				};
+
+				v2m_timer23: timer@12000 {
+					compatible = "arm,sp804", "arm,primecell";
+					reg = <0x12000 0x1000>;
+					interrupts = <3>;
+					clocks = <&v2m_sysctl 2>, <&v2m_sysctl 3>, <&smbclk>;
+					clock-names = "timclken1", "timclken2", "apb_pclk";
+				};
+
+				/* DVI I2C bus */
+				v2m_i2c_dvi: i2c@16000 {
+					compatible = "arm,versatile-i2c";
+					reg = <0x16000 0x1000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					dvi-transmitter@39 {
+						compatible = "sil,sii9022-tpi", "sil,sii9022";
+						reg = <0x39>;
+
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							/*
+							 * Both the core tile and the motherboard routes their output
+							 * pads to this transmitter. The motherboard system controller
+							 * can select one of them as input using a mux register in
+							 * "arm,vexpress-muxfpga". The Vexpress with the CA9 core tile is
+							 * the only platform with this specific set-up.
+							 */
+							port@0 {
+								reg = <0>;
+								dvi_bridge_in_ct: endpoint {
+									remote-endpoint = <&clcd_pads_ct>;
+								};
+							};
+							port@1 {
+								reg = <1>;
+								dvi_bridge_in_mb: endpoint {
+									remote-endpoint = <&clcd_pads_mb>;
+								};
+							};
+						};
+					};
+
+					dvi-transmitter@60 {
+						compatible = "sil,sii9022-cpi", "sil,sii9022";
+						reg = <0x60>;
+					};
+				};
+
+				rtc@17000 {
+					compatible = "arm,pl031", "arm,primecell";
+					reg = <0x17000 0x1000>;
+					interrupts = <4>;
+					clocks = <&smbclk>;
+					clock-names = "apb_pclk";
+				};
+
+				compact-flash@1a000 {
+					compatible = "arm,vexpress-cf", "ata-generic";
+					reg = <0x1a000 0x100
+					       0x1a100 0xf00>;
+					reg-shift = <2>;
+				};
+
+
+				clcd@1f000 {
+					compatible = "arm,pl111", "arm,primecell";
+					reg = <0x1f000 0x1000>;
+					interrupt-names = "combined";
+					interrupts = <14>;
+					clocks = <&v2m_oscclk1>, <&smbclk>;
+					clock-names = "clcdclk", "apb_pclk";
+					/* 800x600 16bpp @36MHz works fine */
+					max-memory-bandwidth = <54000000>;
+					memory-region = <&vram>;
+
+					port {
+						clcd_pads_mb: endpoint {
+							remote-endpoint = <&dvi_bridge_in_mb>;
+							arm,pl11x,tft-r0g0b0-pads = <0 8 16>;
+						};
+					};
+				};
+			};
+
+			v2m_fixed_3v3: fixed-regulator-0 {
+				compatible = "regulator-fixed";
+				regulator-name = "3V3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			v2m_clk24mhz: clk24mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <24000000>;
+				clock-output-names = "v2m:clk24mhz";
+			};
+
+			v2m_refclk1mhz: refclk1mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <1000000>;
+				clock-output-names = "v2m:refclk1mhz";
+			};
+
+			v2m_refclk32khz: refclk32khz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <32768>;
+				clock-output-names = "v2m:refclk32khz";
+			};
+
+			leds {
+				compatible = "gpio-leds";
+
+				user1 {
+					label = "v2m:green:user1";
+					gpios = <&v2m_led_gpios 0 0>;
+					linux,default-trigger = "heartbeat";
+				};
+
+				user2 {
+					label = "v2m:green:user2";
+					gpios = <&v2m_led_gpios 1 0>;
+					linux,default-trigger = "mmc0";
+				};
+
+				user3 {
+					label = "v2m:green:user3";
+					gpios = <&v2m_led_gpios 2 0>;
+					linux,default-trigger = "cpu0";
+				};
+
+				user4 {
+					label = "v2m:green:user4";
+					gpios = <&v2m_led_gpios 3 0>;
+					linux,default-trigger = "cpu1";
+				};
+
+				user5 {
+					label = "v2m:green:user5";
+					gpios = <&v2m_led_gpios 4 0>;
+					linux,default-trigger = "cpu2";
+				};
+
+				user6 {
+					label = "v2m:green:user6";
+					gpios = <&v2m_led_gpios 5 0>;
+					linux,default-trigger = "cpu3";
+				};
+
+				user7 {
+					label = "v2m:green:user7";
+					gpios = <&v2m_led_gpios 6 0>;
+					linux,default-trigger = "cpu4";
+				};
+
+				user8 {
+					label = "v2m:green:user8";
+					gpios = <&v2m_led_gpios 7 0>;
+					linux,default-trigger = "cpu5";
+				};
+			};
+
+			mcc {
+				compatible = "arm,vexpress,config-bus";
+				arm,vexpress,config-bridge = <&v2m_sysreg>;
+
+				oscclk0 {
+					/* MCC static memory clock */
+					compatible = "arm,vexpress-osc";
+					arm,vexpress-sysreg,func = <1 0>;
+					freq-range = <25000000 60000000>;
+					#clock-cells = <0>;
+					clock-output-names = "v2m:oscclk0";
+				};
+
+				v2m_oscclk1: oscclk1 {
+					/* CLCD clock */
+					compatible = "arm,vexpress-osc";
+					arm,vexpress-sysreg,func = <1 1>;
+					freq-range = <23750000 65000000>;
+					#clock-cells = <0>;
+					clock-output-names = "v2m:oscclk1";
+				};
+
+				v2m_oscclk2: oscclk2 {
+					/* IO FPGA peripheral clock */
+					compatible = "arm,vexpress-osc";
+					arm,vexpress-sysreg,func = <1 2>;
+					freq-range = <24000000 24000000>;
+					#clock-cells = <0>;
+					clock-output-names = "v2m:oscclk2";
+				};
+
+				volt-vio {
+					/* Logic level voltage */
+					compatible = "arm,vexpress-volt";
+					arm,vexpress-sysreg,func = <2 0>;
+					regulator-name = "VIO";
+					regulator-always-on;
+					label = "VIO";
+				};
+
+				temp-mcc {
+					/* MCC internal operating temperature */
+					compatible = "arm,vexpress-temp";
+					arm,vexpress-sysreg,func = <4 0>;
+					label = "MCC";
+				};
+
+				reset {
+					compatible = "arm,vexpress-reset";
+					arm,vexpress-sysreg,func = <5 0>;
+				};
+
+				muxfpga {
+					compatible = "arm,vexpress-muxfpga";
+					arm,vexpress-sysreg,func = <7 0>;
+				};
+
+				shutdown {
+					compatible = "arm,vexpress-shutdown";
+					arm,vexpress-sysreg,func = <8 0>;
+				};
+
+				reboot {
+					compatible = "arm,vexpress-reboot";
+					arm,vexpress-sysreg,func = <9 0>;
+				};
+
+				dvimode {
+					compatible = "arm,vexpress-dvimode";
+					arm,vexpress-sysreg,func = <11 0>;
+				};
+			};
+		};
+	};
+};
diff -ruN linux-5.0.2a/arch/arm/boot/dts/vexpress-v2p-pds03.dts linux-5.0.2b/arch/arm/boot/dts/vexpress-v2p-pds03.dts
--- linux-5.0.2a/arch/arm/boot/dts/vexpress-v2p-pds03.dts	1969-12-31 16:00:00.000000000 -0800
+++ linux-5.0.2b/arch/arm/boot/dts/vexpress-v2p-pds03.dts	2020-09-18 08:00:21.152668485 -0700
@@ -0,0 +1,368 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * CoreTile Express A9x4
+ * Cortex-A9 MPCore (V2P-CA9)
+ *
+ * HBI-0191B
+ */
+
+/dts-v1/;
+#include "vexpress-v2m-pds03.dtsi"
+
+/ {
+	model = "V2P-CA9";
+	arm,hbi = <0x191>;
+	arm,vexpress,site = <0xf>;
+	compatible = "arm,vexpress,v2p-ca9", "arm,vexpress";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen { };
+
+	aliases {
+		serial0 = &v2m_serial0;
+		serial1 = &v2m_serial1;
+		serial2 = &v2m_serial2;
+		serial3 = &v2m_serial3;
+		i2c0 = &v2m_i2c_dvi;
+		i2c1 = &v2m_i2c_pcie;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		A9_0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0>;
+			next-level-cache = <&L2>;
+		};
+
+		A9_1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <1>;
+			next-level-cache = <&L2>;
+		};
+
+		A9_2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <2>;
+			next-level-cache = <&L2>;
+		};
+
+		A9_3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	memory@60000000 {
+		device_type = "memory";
+		reg = <0x60000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/* Chipselect 3 is physically at 0x4c000000 */
+		vram: vram@4c000000 {
+			/* 8 MB of designated video RAM */
+			compatible = "shared-dma-pool";
+			reg = <0x4c000000 0x00800000>;
+			no-map;
+		};
+	};
+
+	clcd@10020000 {
+		compatible = "arm,pl111", "arm,primecell";
+		reg = <0x10020000 0x1000>;
+		interrupt-names = "combined";
+		interrupts = <0 44 4>;
+		clocks = <&oscclk1>, <&oscclk2>;
+		clock-names = "clcdclk", "apb_pclk";
+		/* 1024x768 16bpp @65MHz */
+		max-memory-bandwidth = <95000000>;
+
+		port {
+			clcd_pads_ct: endpoint {
+				remote-endpoint = <&dvi_bridge_in_ct>;
+				arm,pl11x,tft-r0g0b0-pads = <0 8 16>;
+			};
+		};
+	};
+
+	memory-controller@100e0000 {
+		compatible = "arm,pl341", "arm,primecell";
+		reg = <0x100e0000 0x1000>;
+		clocks = <&oscclk2>;
+		clock-names = "apb_pclk";
+	};
+
+	memory-controller@100e1000 {
+		compatible = "arm,pl354", "arm,primecell";
+		reg = <0x100e1000 0x1000>;
+		interrupts = <0 45 4>,
+			     <0 46 4>;
+		clocks = <&oscclk2>;
+		clock-names = "apb_pclk";
+	};
+
+	timer@100e4000 {
+		compatible = "arm,sp804", "arm,primecell";
+		reg = <0x100e4000 0x1000>;
+		interrupts = <0 48 4>,
+			     <0 49 4>;
+		clocks = <&oscclk2>, <&oscclk2>;
+		clock-names = "timclk", "apb_pclk";
+		status = "disabled";
+	};
+
+	watchdog@100e5000 {
+		compatible = "arm,sp805", "arm,primecell";
+		reg = <0x100e5000 0x1000>;
+		interrupts = <0 51 4>;
+		clocks = <&oscclk2>, <&oscclk2>;
+		clock-names = "wdogclk", "apb_pclk";
+	};
+
+	scu@1e000000 {
+		compatible = "arm,cortex-a9-scu";
+		reg = <0x1e000000 0x58>;
+	};
+
+	timer@1e000600 {
+		compatible = "arm,cortex-a9-twd-timer";
+		reg = <0x1e000600 0x20>;
+		interrupts = <1 13 0xf04>;
+	};
+
+	watchdog@1e000620 {
+		compatible = "arm,cortex-a9-twd-wdt";
+		reg = <0x1e000620 0x20>;
+		interrupts = <1 14 0xf04>;
+	};
+
+	gic: interrupt-controller@1e001000 {
+		compatible = "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x1e001000 0x1000>,
+		      <0x1e000100 0x100>;
+	};
+
+	L2: cache-controller@1e00a000 {
+		compatible = "arm,pl310-cache";
+		reg = <0x1e00a000 0x1000>;
+		interrupts = <0 43 4>;
+		cache-unified;
+		cache-level = <2>;
+		arm,data-latency = <1 1 1>;
+		arm,tag-latency = <1 1 1>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a9-pmu";
+		interrupts = <0 60 4>,
+			     <0 61 4>,
+			     <0 62 4>,
+			     <0 63 4>;
+		interrupt-affinity = <&A9_0>, <&A9_1>, <&A9_2>, <&A9_3>;
+
+	};
+
+	dcc {
+		compatible = "arm,vexpress,config-bus";
+		arm,vexpress,config-bridge = <&v2m_sysreg>;
+
+		oscclk0: extsaxiclk {
+			/* ACLK clock to the AXI master port on the test chip */
+			compatible = "arm,vexpress-osc";
+			arm,vexpress-sysreg,func = <1 0>;
+			freq-range = <30000000 50000000>;
+			#clock-cells = <0>;
+			clock-output-names = "extsaxiclk";
+		};
+
+		oscclk1: clcdclk {
+			/* Reference clock for the CLCD */
+			compatible = "arm,vexpress-osc";
+			arm,vexpress-sysreg,func = <1 1>;
+			freq-range = <10000000 80000000>;
+			#clock-cells = <0>;
+			clock-output-names = "clcdclk";
+		};
+
+		smbclk: oscclk2: tcrefclk {
+			/* Reference clock for the test chip internal PLLs */
+			compatible = "arm,vexpress-osc";
+			arm,vexpress-sysreg,func = <1 2>;
+			freq-range = <33000000 100000000>;
+			#clock-cells = <0>;
+			clock-output-names = "tcrefclk";
+		};
+
+		volt-vd10 {
+			/* Test Chip internal logic voltage */
+			compatible = "arm,vexpress-volt";
+			arm,vexpress-sysreg,func = <2 0>;
+			regulator-name = "VD10";
+			regulator-always-on;
+			label = "VD10";
+		};
+
+		volt-vd10-s2 {
+			/* PL310, L2 cache, RAM cell supply (not PL310 logic) */
+			compatible = "arm,vexpress-volt";
+			arm,vexpress-sysreg,func = <2 1>;
+			regulator-name = "VD10_S2";
+			regulator-always-on;
+			label = "VD10_S2";
+		};
+
+		volt-vd10-s3 {
+			/* Cortex-A9 system supply, Cores, MPEs, SCU and PL310 logic */
+			compatible = "arm,vexpress-volt";
+			arm,vexpress-sysreg,func = <2 2>;
+			regulator-name = "VD10_S3";
+			regulator-always-on;
+			label = "VD10_S3";
+		};
+
+		volt-vcc1v8 {
+			/* DDR2 SDRAM and Test Chip DDR2 I/O supply */
+			compatible = "arm,vexpress-volt";
+			arm,vexpress-sysreg,func = <2 3>;
+			regulator-name = "VCC1V8";
+			regulator-always-on;
+			label = "VCC1V8";
+		};
+
+		volt-ddr2vtt {
+			/* DDR2 SDRAM VTT termination voltage */
+			compatible = "arm,vexpress-volt";
+			arm,vexpress-sysreg,func = <2 4>;
+			regulator-name = "DDR2VTT";
+			regulator-always-on;
+			label = "DDR2VTT";
+		};
+
+		volt-vcc3v3 {
+			/* Local board supply for miscellaneous logic external to the Test Chip */
+			arm,vexpress-sysreg,func = <2 5>;
+			compatible = "arm,vexpress-volt";
+			regulator-name = "VCC3V3";
+			regulator-always-on;
+			label = "VCC3V3";
+		};
+
+		amp-vd10-s2 {
+			/* PL310, L2 cache, RAM cell supply (not PL310 logic) */
+			compatible = "arm,vexpress-amp";
+			arm,vexpress-sysreg,func = <3 0>;
+			label = "VD10_S2";
+		};
+
+		amp-vd10-s3 {
+			/* Cortex-A9 system supply, Cores, MPEs, SCU and PL310 logic */
+			compatible = "arm,vexpress-amp";
+			arm,vexpress-sysreg,func = <3 1>;
+			label = "VD10_S3";
+		};
+
+		power-vd10-s2 {
+			/* PL310, L2 cache, RAM cell supply (not PL310 logic) */
+			compatible = "arm,vexpress-power";
+			arm,vexpress-sysreg,func = <12 0>;
+			label = "PVD10_S2";
+		};
+
+		power-vd10-s3 {
+			/* Cortex-A9 system supply, Cores, MPEs, SCU and PL310 logic */
+			compatible = "arm,vexpress-power";
+			arm,vexpress-sysreg,func = <12 1>;
+			label = "PVD10_S3";
+		};
+	};
+
+	smb: smb@4000000 {
+		compatible = "simple-bus";
+
+		#address-cells = <2>;
+		#size-cells = <1>;
+		ranges = <0 0 0x40000000 0x04000000>,
+			 <1 0 0x44000000 0x04000000>,
+			 <2 0 0x48000000 0x04000000>,
+			 <3 0 0x4c000000 0x04000000>,
+			 <7 0 0x10000000 0x00020000>;
+
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 63>;
+		interrupt-map = <0 0  0 &gic 0  0 4>,
+				<0 0  1 &gic 0  1 4>,
+				<0 0  2 &gic 0  2 4>,
+				<0 0  3 &gic 0  3 4>,
+				<0 0  4 &gic 0  4 4>,
+				<0 0  5 &gic 0  5 4>,
+				<0 0  6 &gic 0  6 4>,
+				<0 0  7 &gic 0  7 4>,
+				<0 0  8 &gic 0  8 4>,
+				<0 0  9 &gic 0  9 4>,
+				<0 0 10 &gic 0 10 4>,
+				<0 0 11 &gic 0 11 4>,
+				<0 0 12 &gic 0 12 4>,
+				<0 0 13 &gic 0 13 4>,
+				<0 0 14 &gic 0 14 4>,
+				<0 0 15 &gic 0 15 4>,
+				<0 0 16 &gic 0 16 4>,
+				<0 0 17 &gic 0 17 4>,
+				<0 0 18 &gic 0 18 4>,
+				<0 0 19 &gic 0 19 4>,
+				<0 0 20 &gic 0 20 4>,
+				<0 0 21 &gic 0 21 4>,
+				<0 0 22 &gic 0 22 4>,
+				<0 0 23 &gic 0 23 4>,
+				<0 0 24 &gic 0 24 4>,
+				<0 0 25 &gic 0 25 4>,
+				<0 0 26 &gic 0 26 4>,
+				<0 0 27 &gic 0 27 4>,
+				<0 0 28 &gic 0 28 4>,
+				<0 0 29 &gic 0 29 4>,
+				<0 0 30 &gic 0 30 4>,
+				<0 0 31 &gic 0 31 4>,
+				<0 0 32 &gic 0 32 4>,
+				<0 0 33 &gic 0 33 4>,
+				<0 0 34 &gic 0 34 4>,
+				<0 0 35 &gic 0 35 4>,
+				<0 0 36 &gic 0 36 4>,
+				<0 0 37 &gic 0 37 4>,
+				<0 0 38 &gic 0 38 4>,
+				<0 0 39 &gic 0 39 4>,
+				<0 0 40 &gic 0 40 4>,
+				<0 0 41 &gic 0 41 4>,
+				<0 0 42 &gic 0 42 4>;
+	};
+
+	site2: hsb@e0000000 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0xe0000000 0x20000000>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 3>;
+		interrupt-map = <0 0 &gic 0 36 4>,
+				<0 1 &gic 0 37 4>,
+				<0 2 &gic 0 38 4>,
+				<0 3 &gic 0 39 4>;
+	};
+};
diff -ruN linux-5.0.2a/.clang-format linux-5.0.2b/.clang-format
--- linux-5.0.2a/.clang-format	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/.clang-format	1969-12-31 16:00:00.000000000 -0800
@@ -1,468 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# clang-format configuration file. Intended for clang-format >= 4.
-#
-# For more information, see:
-#
-#   Documentation/process/clang-format.rst
-#   https://clang.llvm.org/docs/ClangFormat.html
-#   https://clang.llvm.org/docs/ClangFormatStyleOptions.html
-#
----
-AccessModifierOffset: -4
-AlignAfterOpenBracket: Align
-AlignConsecutiveAssignments: false
-AlignConsecutiveDeclarations: false
-#AlignEscapedNewlines: Left # Unknown to clang-format-4.0
-AlignOperands: true
-AlignTrailingComments: false
-AllowAllParametersOfDeclarationOnNextLine: false
-AllowShortBlocksOnASingleLine: false
-AllowShortCaseLabelsOnASingleLine: false
-AllowShortFunctionsOnASingleLine: None
-AllowShortIfStatementsOnASingleLine: false
-AllowShortLoopsOnASingleLine: false
-AlwaysBreakAfterDefinitionReturnType: None
-AlwaysBreakAfterReturnType: None
-AlwaysBreakBeforeMultilineStrings: false
-AlwaysBreakTemplateDeclarations: false
-BinPackArguments: true
-BinPackParameters: true
-BraceWrapping:
-  AfterClass: false
-  AfterControlStatement: false
-  AfterEnum: false
-  AfterFunction: true
-  AfterNamespace: true
-  AfterObjCDeclaration: false
-  AfterStruct: false
-  AfterUnion: false
-  #AfterExternBlock: false # Unknown to clang-format-5.0
-  BeforeCatch: false
-  BeforeElse: false
-  IndentBraces: false
-  #SplitEmptyFunction: true # Unknown to clang-format-4.0
-  #SplitEmptyRecord: true # Unknown to clang-format-4.0
-  #SplitEmptyNamespace: true # Unknown to clang-format-4.0
-BreakBeforeBinaryOperators: None
-BreakBeforeBraces: Custom
-#BreakBeforeInheritanceComma: false # Unknown to clang-format-4.0
-BreakBeforeTernaryOperators: false
-BreakConstructorInitializersBeforeComma: false
-#BreakConstructorInitializers: BeforeComma # Unknown to clang-format-4.0
-BreakAfterJavaFieldAnnotations: false
-BreakStringLiterals: false
-ColumnLimit: 80
-CommentPragmas: '^ IWYU pragma:'
-#CompactNamespaces: false # Unknown to clang-format-4.0
-ConstructorInitializerAllOnOneLineOrOnePerLine: false
-ConstructorInitializerIndentWidth: 8
-ContinuationIndentWidth: 8
-Cpp11BracedListStyle: false
-DerivePointerAlignment: false
-DisableFormat: false
-ExperimentalAutoDetectBinPacking: false
-#FixNamespaceComments: false # Unknown to clang-format-4.0
-
-# Taken from:
-#   git grep -h '^#define [^[:space:]]*for_each[^[:space:]]*(' include/ \
-#   | sed "s,^#define \([^[:space:]]*for_each[^[:space:]]*\)(.*$,  - '\1'," \
-#   | sort | uniq
-ForEachMacros:
-  - 'apei_estatus_for_each_section'
-  - 'ata_for_each_dev'
-  - 'ata_for_each_link'
-  - '__ata_qc_for_each'
-  - 'ata_qc_for_each'
-  - 'ata_qc_for_each_raw'
-  - 'ata_qc_for_each_with_internal'
-  - 'ax25_for_each'
-  - 'ax25_uid_for_each'
-  - 'bio_for_each_integrity_vec'
-  - '__bio_for_each_segment'
-  - 'bio_for_each_segment'
-  - 'bio_for_each_segment_all'
-  - 'bio_list_for_each'
-  - 'bip_for_each_vec'
-  - 'blkg_for_each_descendant_post'
-  - 'blkg_for_each_descendant_pre'
-  - 'blk_queue_for_each_rl'
-  - 'bond_for_each_slave'
-  - 'bond_for_each_slave_rcu'
-  - 'bpf_for_each_spilled_reg'
-  - 'btree_for_each_safe128'
-  - 'btree_for_each_safe32'
-  - 'btree_for_each_safe64'
-  - 'btree_for_each_safel'
-  - 'card_for_each_dev'
-  - 'cgroup_taskset_for_each'
-  - 'cgroup_taskset_for_each_leader'
-  - 'cpufreq_for_each_entry'
-  - 'cpufreq_for_each_entry_idx'
-  - 'cpufreq_for_each_valid_entry'
-  - 'cpufreq_for_each_valid_entry_idx'
-  - 'css_for_each_child'
-  - 'css_for_each_descendant_post'
-  - 'css_for_each_descendant_pre'
-  - 'device_for_each_child_node'
-  - 'drm_atomic_crtc_for_each_plane'
-  - 'drm_atomic_crtc_state_for_each_plane'
-  - 'drm_atomic_crtc_state_for_each_plane_state'
-  - 'drm_atomic_for_each_plane_damage'
-  - 'drm_connector_for_each_possible_encoder'
-  - 'drm_for_each_connector_iter'
-  - 'drm_for_each_crtc'
-  - 'drm_for_each_encoder'
-  - 'drm_for_each_encoder_mask'
-  - 'drm_for_each_fb'
-  - 'drm_for_each_legacy_plane'
-  - 'drm_for_each_plane'
-  - 'drm_for_each_plane_mask'
-  - 'drm_mm_for_each_hole'
-  - 'drm_mm_for_each_node'
-  - 'drm_mm_for_each_node_in_range'
-  - 'drm_mm_for_each_node_safe'
-  - 'for_each_active_drhd_unit'
-  - 'for_each_active_iommu'
-  - 'for_each_available_child_of_node'
-  - 'for_each_bio'
-  - 'for_each_board_func_rsrc'
-  - 'for_each_bvec'
-  - 'for_each_card_components'
-  - 'for_each_card_links'
-  - 'for_each_card_links_safe'
-  - 'for_each_card_prelinks'
-  - 'for_each_card_rtds'
-  - 'for_each_card_rtds_safe'
-  - 'for_each_cgroup_storage_type'
-  - 'for_each_child_of_node'
-  - 'for_each_clear_bit'
-  - 'for_each_clear_bit_from'
-  - 'for_each_cmsghdr'
-  - 'for_each_compatible_node'
-  - 'for_each_component_dais'
-  - 'for_each_component_dais_safe'
-  - 'for_each_comp_order'
-  - 'for_each_console'
-  - 'for_each_cpu'
-  - 'for_each_cpu_and'
-  - 'for_each_cpu_not'
-  - 'for_each_cpu_wrap'
-  - 'for_each_dev_addr'
-  - 'for_each_dma_cap_mask'
-  - 'for_each_dpcm_be'
-  - 'for_each_dpcm_be_rollback'
-  - 'for_each_dpcm_be_safe'
-  - 'for_each_dpcm_fe'
-  - 'for_each_drhd_unit'
-  - 'for_each_dss_dev'
-  - 'for_each_efi_memory_desc'
-  - 'for_each_efi_memory_desc_in_map'
-  - 'for_each_endpoint_of_node'
-  - 'for_each_evictable_lru'
-  - 'for_each_fib6_node_rt_rcu'
-  - 'for_each_fib6_walker_rt'
-  - 'for_each_free_mem_range'
-  - 'for_each_free_mem_range_reverse'
-  - 'for_each_func_rsrc'
-  - 'for_each_hstate'
-  - 'for_each_if'
-  - 'for_each_iommu'
-  - 'for_each_ip_tunnel_rcu'
-  - 'for_each_irq_nr'
-  - 'for_each_link_codecs'
-  - 'for_each_lru'
-  - 'for_each_matching_node'
-  - 'for_each_matching_node_and_match'
-  - 'for_each_memblock'
-  - 'for_each_memblock_type'
-  - 'for_each_memcg_cache_index'
-  - 'for_each_mem_pfn_range'
-  - 'for_each_mem_range'
-  - 'for_each_mem_range_rev'
-  - 'for_each_migratetype_order'
-  - 'for_each_msi_entry'
-  - 'for_each_msi_entry_safe'
-  - 'for_each_net'
-  - 'for_each_netdev'
-  - 'for_each_netdev_continue'
-  - 'for_each_netdev_continue_rcu'
-  - 'for_each_netdev_feature'
-  - 'for_each_netdev_in_bond_rcu'
-  - 'for_each_netdev_rcu'
-  - 'for_each_netdev_reverse'
-  - 'for_each_netdev_safe'
-  - 'for_each_net_rcu'
-  - 'for_each_new_connector_in_state'
-  - 'for_each_new_crtc_in_state'
-  - 'for_each_new_plane_in_state'
-  - 'for_each_new_private_obj_in_state'
-  - 'for_each_node'
-  - 'for_each_node_by_name'
-  - 'for_each_node_by_type'
-  - 'for_each_node_mask'
-  - 'for_each_node_state'
-  - 'for_each_node_with_cpus'
-  - 'for_each_node_with_property'
-  - 'for_each_of_allnodes'
-  - 'for_each_of_allnodes_from'
-  - 'for_each_of_cpu_node'
-  - 'for_each_of_pci_range'
-  - 'for_each_old_connector_in_state'
-  - 'for_each_old_crtc_in_state'
-  - 'for_each_oldnew_connector_in_state'
-  - 'for_each_oldnew_crtc_in_state'
-  - 'for_each_oldnew_plane_in_state'
-  - 'for_each_oldnew_plane_in_state_reverse'
-  - 'for_each_oldnew_private_obj_in_state'
-  - 'for_each_old_plane_in_state'
-  - 'for_each_old_private_obj_in_state'
-  - 'for_each_online_cpu'
-  - 'for_each_online_node'
-  - 'for_each_online_pgdat'
-  - 'for_each_pci_bridge'
-  - 'for_each_pci_dev'
-  - 'for_each_pci_msi_entry'
-  - 'for_each_populated_zone'
-  - 'for_each_possible_cpu'
-  - 'for_each_present_cpu'
-  - 'for_each_prime_number'
-  - 'for_each_prime_number_from'
-  - 'for_each_process'
-  - 'for_each_process_thread'
-  - 'for_each_property_of_node'
-  - 'for_each_registered_fb'
-  - 'for_each_reserved_mem_region'
-  - 'for_each_rtd_codec_dai'
-  - 'for_each_rtd_codec_dai_rollback'
-  - 'for_each_rtdcom'
-  - 'for_each_rtdcom_safe'
-  - 'for_each_set_bit'
-  - 'for_each_set_bit_from'
-  - 'for_each_sg'
-  - 'for_each_sg_page'
-  - 'for_each_sibling_event'
-  - '__for_each_thread'
-  - 'for_each_thread'
-  - 'for_each_zone'
-  - 'for_each_zone_zonelist'
-  - 'for_each_zone_zonelist_nodemask'
-  - 'fwnode_for_each_available_child_node'
-  - 'fwnode_for_each_child_node'
-  - 'fwnode_graph_for_each_endpoint'
-  - 'gadget_for_each_ep'
-  - 'hash_for_each'
-  - 'hash_for_each_possible'
-  - 'hash_for_each_possible_rcu'
-  - 'hash_for_each_possible_rcu_notrace'
-  - 'hash_for_each_possible_safe'
-  - 'hash_for_each_rcu'
-  - 'hash_for_each_safe'
-  - 'hctx_for_each_ctx'
-  - 'hlist_bl_for_each_entry'
-  - 'hlist_bl_for_each_entry_rcu'
-  - 'hlist_bl_for_each_entry_safe'
-  - 'hlist_for_each'
-  - 'hlist_for_each_entry'
-  - 'hlist_for_each_entry_continue'
-  - 'hlist_for_each_entry_continue_rcu'
-  - 'hlist_for_each_entry_continue_rcu_bh'
-  - 'hlist_for_each_entry_from'
-  - 'hlist_for_each_entry_from_rcu'
-  - 'hlist_for_each_entry_rcu'
-  - 'hlist_for_each_entry_rcu_bh'
-  - 'hlist_for_each_entry_rcu_notrace'
-  - 'hlist_for_each_entry_safe'
-  - '__hlist_for_each_rcu'
-  - 'hlist_for_each_safe'
-  - 'hlist_nulls_for_each_entry'
-  - 'hlist_nulls_for_each_entry_from'
-  - 'hlist_nulls_for_each_entry_rcu'
-  - 'hlist_nulls_for_each_entry_safe'
-  - 'i3c_bus_for_each_i2cdev'
-  - 'i3c_bus_for_each_i3cdev'
-  - 'ide_host_for_each_port'
-  - 'ide_port_for_each_dev'
-  - 'ide_port_for_each_present_dev'
-  - 'idr_for_each_entry'
-  - 'idr_for_each_entry_continue'
-  - 'idr_for_each_entry_ul'
-  - 'inet_bind_bucket_for_each'
-  - 'inet_lhash2_for_each_icsk_rcu'
-  - 'iov_for_each'
-  - 'key_for_each'
-  - 'key_for_each_safe'
-  - 'klp_for_each_func'
-  - 'klp_for_each_object'
-  - 'kvm_for_each_memslot'
-  - 'kvm_for_each_vcpu'
-  - 'list_for_each'
-  - 'list_for_each_codec'
-  - 'list_for_each_codec_safe'
-  - 'list_for_each_entry'
-  - 'list_for_each_entry_continue'
-  - 'list_for_each_entry_continue_rcu'
-  - 'list_for_each_entry_continue_reverse'
-  - 'list_for_each_entry_from'
-  - 'list_for_each_entry_from_rcu'
-  - 'list_for_each_entry_from_reverse'
-  - 'list_for_each_entry_lockless'
-  - 'list_for_each_entry_rcu'
-  - 'list_for_each_entry_reverse'
-  - 'list_for_each_entry_safe'
-  - 'list_for_each_entry_safe_continue'
-  - 'list_for_each_entry_safe_from'
-  - 'list_for_each_entry_safe_reverse'
-  - 'list_for_each_prev'
-  - 'list_for_each_prev_safe'
-  - 'list_for_each_safe'
-  - 'llist_for_each'
-  - 'llist_for_each_entry'
-  - 'llist_for_each_entry_safe'
-  - 'llist_for_each_safe'
-  - 'media_device_for_each_entity'
-  - 'media_device_for_each_intf'
-  - 'media_device_for_each_link'
-  - 'media_device_for_each_pad'
-  - 'nanddev_io_for_each_page'
-  - 'netdev_for_each_lower_dev'
-  - 'netdev_for_each_lower_private'
-  - 'netdev_for_each_lower_private_rcu'
-  - 'netdev_for_each_mc_addr'
-  - 'netdev_for_each_uc_addr'
-  - 'netdev_for_each_upper_dev_rcu'
-  - 'netdev_hw_addr_list_for_each'
-  - 'nft_rule_for_each_expr'
-  - 'nla_for_each_attr'
-  - 'nla_for_each_nested'
-  - 'nlmsg_for_each_attr'
-  - 'nlmsg_for_each_msg'
-  - 'nr_neigh_for_each'
-  - 'nr_neigh_for_each_safe'
-  - 'nr_node_for_each'
-  - 'nr_node_for_each_safe'
-  - 'of_for_each_phandle'
-  - 'of_property_for_each_string'
-  - 'of_property_for_each_u32'
-  - 'pci_bus_for_each_resource'
-  - 'ping_portaddr_for_each_entry'
-  - 'plist_for_each'
-  - 'plist_for_each_continue'
-  - 'plist_for_each_entry'
-  - 'plist_for_each_entry_continue'
-  - 'plist_for_each_entry_safe'
-  - 'plist_for_each_safe'
-  - 'pnp_for_each_card'
-  - 'pnp_for_each_dev'
-  - 'protocol_for_each_card'
-  - 'protocol_for_each_dev'
-  - 'queue_for_each_hw_ctx'
-  - 'radix_tree_for_each_slot'
-  - 'radix_tree_for_each_tagged'
-  - 'rbtree_postorder_for_each_entry_safe'
-  - 'resource_list_for_each_entry'
-  - 'resource_list_for_each_entry_safe'
-  - 'rhl_for_each_entry_rcu'
-  - 'rhl_for_each_rcu'
-  - 'rht_for_each'
-  - 'rht_for_each_continue'
-  - 'rht_for_each_entry'
-  - 'rht_for_each_entry_continue'
-  - 'rht_for_each_entry_rcu'
-  - 'rht_for_each_entry_rcu_continue'
-  - 'rht_for_each_entry_safe'
-  - 'rht_for_each_rcu'
-  - 'rht_for_each_rcu_continue'
-  - '__rq_for_each_bio'
-  - 'rq_for_each_segment'
-  - 'scsi_for_each_prot_sg'
-  - 'scsi_for_each_sg'
-  - 'sctp_for_each_hentry'
-  - 'sctp_skb_for_each'
-  - 'shdma_for_each_chan'
-  - '__shost_for_each_device'
-  - 'shost_for_each_device'
-  - 'sk_for_each'
-  - 'sk_for_each_bound'
-  - 'sk_for_each_entry_offset_rcu'
-  - 'sk_for_each_from'
-  - 'sk_for_each_rcu'
-  - 'sk_for_each_safe'
-  - 'sk_nulls_for_each'
-  - 'sk_nulls_for_each_from'
-  - 'sk_nulls_for_each_rcu'
-  - 'snd_array_for_each'
-  - 'snd_pcm_group_for_each_entry'
-  - 'snd_soc_dapm_widget_for_each_path'
-  - 'snd_soc_dapm_widget_for_each_path_safe'
-  - 'snd_soc_dapm_widget_for_each_sink_path'
-  - 'snd_soc_dapm_widget_for_each_source_path'
-  - 'tb_property_for_each'
-  - 'tcf_exts_for_each_action'
-  - 'udp_portaddr_for_each_entry'
-  - 'udp_portaddr_for_each_entry_rcu'
-  - 'usb_hub_for_each_child'
-  - 'v4l2_device_for_each_subdev'
-  - 'v4l2_m2m_for_each_dst_buf'
-  - 'v4l2_m2m_for_each_dst_buf_safe'
-  - 'v4l2_m2m_for_each_src_buf'
-  - 'v4l2_m2m_for_each_src_buf_safe'
-  - 'virtio_device_for_each_vq'
-  - 'xa_for_each'
-  - 'xas_for_each'
-  - 'xas_for_each_conflict'
-  - 'xas_for_each_marked'
-  - 'zorro_for_each_dev'
-
-#IncludeBlocks: Preserve # Unknown to clang-format-5.0
-IncludeCategories:
-  - Regex: '.*'
-    Priority: 1
-IncludeIsMainRegex: '(Test)?$'
-IndentCaseLabels: false
-#IndentPPDirectives: None # Unknown to clang-format-5.0
-IndentWidth: 8
-IndentWrappedFunctionNames: false
-JavaScriptQuotes: Leave
-JavaScriptWrapImports: true
-KeepEmptyLinesAtTheStartOfBlocks: false
-MacroBlockBegin: ''
-MacroBlockEnd: ''
-MaxEmptyLinesToKeep: 1
-NamespaceIndentation: Inner
-#ObjCBinPackProtocolList: Auto # Unknown to clang-format-5.0
-ObjCBlockIndentWidth: 8
-ObjCSpaceAfterProperty: true
-ObjCSpaceBeforeProtocolList: true
-
-# Taken from git's rules
-#PenaltyBreakAssignment: 10 # Unknown to clang-format-4.0
-PenaltyBreakBeforeFirstCallParameter: 30
-PenaltyBreakComment: 10
-PenaltyBreakFirstLessLess: 0
-PenaltyBreakString: 10
-PenaltyExcessCharacter: 100
-PenaltyReturnTypeOnItsOwnLine: 60
-
-PointerAlignment: Right
-ReflowComments: false
-SortIncludes: false
-#SortUsingDeclarations: false # Unknown to clang-format-4.0
-SpaceAfterCStyleCast: false
-SpaceAfterTemplateKeyword: true
-SpaceBeforeAssignmentOperators: true
-#SpaceBeforeCtorInitializerColon: true # Unknown to clang-format-5.0
-#SpaceBeforeInheritanceColon: true # Unknown to clang-format-5.0
-SpaceBeforeParens: ControlStatements
-#SpaceBeforeRangeBasedForLoopColon: true # Unknown to clang-format-5.0
-SpaceInEmptyParentheses: false
-SpacesBeforeTrailingComments: 1
-SpacesInAngles: false
-SpacesInContainerLiterals: false
-SpacesInCStyleCastParentheses: false
-SpacesInParentheses: false
-SpacesInSquareBrackets: false
-Standard: Cpp03
-TabWidth: 8
-UseTab: Always
-...
diff -ruN linux-5.0.2a/.cocciconfig linux-5.0.2b/.cocciconfig
--- linux-5.0.2a/.cocciconfig	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/.cocciconfig	1969-12-31 16:00:00.000000000 -0800
@@ -1,3 +0,0 @@
-[spatch]
-	options = --timeout 200
-	options = --use-gitgrep
diff -ruN linux-5.0.2a/drivers/char/etf-pds-03.c linux-5.0.2b/drivers/char/etf-pds-03.c
--- linux-5.0.2a/drivers/char/etf-pds-03.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-5.0.2b/drivers/char/etf-pds-03.c	2020-09-22 20:28:13.122841000 -0700
@@ -0,0 +1,389 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#define PDS03_DEVICE_FILE_NAME "pds03mmsensor"
+#define PDS03_DRIVER_NAME "pds03drv"
+#define PDS03_MMSENSOR_CTRL_OFFSET      (0x00)
+#define PDS03_MMSENSOR_FREQ_OFFSET      (0x02)
+#define PDS03_MMSENSOR_STATUS_OFFSET    (0x04)
+#define PDS03_MMSENSOR_DATA_OFFSET      (0x08)
+#define PDS03_MMSENSOR_CTRL_EN_MASK     (0x00010000)
+#define PDS03_MMSENSOR_CTRL_IEN_MASK    (0x00020000)
+#define PDS03_MMSENSOR_CTRL_RES_MASK    (0x00040000)
+#define PDS03_MMSENSOR_CTRL_FREQ_MASK	(0x00080000)
+#define PDS03_MMSENSOR_STATUS_IFG_MASK  (0x00020000)
+#define PDS03_MMSENSOR_DATA_MASK        (0x0000FFFF)
+#define PDS03_12BIT_RESOLUTION_CTRL	(0x00000000)
+#define PDS03_8BIT_RESOLUTION_CTRL	(0x00040000)
+#define PDS03_NORMAL_FREQUENCY_CTRL	(0x00000000)
+#define PDS03_FAST_FREQUENCY_CTRL	(0x00080000)
+/** 
+ * * struct pds03_mmsensor - PDS03 Memory Mapped private data structure
+ * @base_addr: base address of the device
+ * @irq:       interrupt for the device
+ * @dev:       struct device pointer
+ * @cdev:      struct cdev
+ * @devt:      dev_t member
+ * @alarm:     set if alarm is active
+ */
+struct pds03_mmsensor {
+       void __iomem *base_addr;
+       int irq;
+       struct device *dev;
+       struct device *parent;
+       struct cdev cdev;
+       dev_t devt;
+       int mmsensor;
+};
+/* global so it can be destroyed when module is removed */
+static struct class* pds03_mmsensor_class;
+/* Convertion to mV for memory mapped sensor */
+static inline u16 pds_03_to_mV(u16 value)
+{
+	return (value*1000)/2048;
+}
+static int pds03_mmsensordev_open(struct inode *inode, struct file *filp) {
+       struct pds03_mmsensor *demodev;
+       /* store demodev pointer for read */
+       demodev = container_of(inode->i_cdev, struct pds03_mmsensor, cdev);
+       filp->private_data = demodev;
+       printk("pds03_mmsensordev_open called\n");
+       return 0;
+}
+static int pds03_mmsensordev_release(struct inode *inode, struct file *filp) {
+       printk("pds03_mmsensordev_release called\n");
+       return 0;
+}
+static ssize_t pds03_mmsensordev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) {
+       struct pds03_mmsensor *demodev;
+       /* buffer */
+       static char buffer[10];
+       /* Number of bytes written to the buffer */
+       ssize_t bytes_read = 0;
+       /* data storage */
+       int data_reg;
+       if (*f_pos) {
+               *f_pos = 0;
+               return 0;
+       }
+       demodev = filp->private_data;
+       /* read data from DATA register */
+       data_reg = ioread32(demodev->base_addr + PDS03_MMSENSOR_DATA_OFFSET);
+       /* pack it into buffer */
+       sprintf(buffer, "%d\n", data_reg);
+       bytes_read = strlen(buffer);
+       /* copy_to_user */
+       if (copy_to_user(buf, buffer, bytes_read)) {
+               return -EFAULT;
+       }
+       *f_pos += bytes_read;
+       printk("pds03_mmsensordev_read called\n");
+       /* return number of bytes read */
+       return bytes_read;
+}
+static ssize_t pds03_mmsensordev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) 
+{
+       pr_alert("not implemented\n");
+       return -EINVAL;
+}
+static struct file_operations pds03_mmsensordev_fops = {
+	.owner = THIS_MODULE,
+	.open = pds03_mmsensordev_open,
+	.release = pds03_mmsensordev_release,
+	.read = pds03_mmsensordev_read,
+	.write = pds03_mmsensordev_write,
+	};
+static ssize_t pds03_mmsensor_enabling_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 enabling_component_pds03 = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	enabling_component_pds03 &= PDS03_MMSENSOR_CTRL_EN_MASK;
+        printk("pds03_mmsensordev_enabling_show called\n");
+	return sprintf(buf, "%d\n", !!enabling_component_pds03);
+}
+static ssize_t pds03_mmsensor_enabling_store(struct device *child, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 ctrl = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	int enabling_component_pds03;
+	sscanf(buf, "%d", &enabling_component_pds03);
+	if (!enabling_component_pds03) {
+		ctrl &= ~PDS03_MMSENSOR_CTRL_EN_MASK;
+	} else {
+		ctrl |= PDS03_MMSENSOR_CTRL_EN_MASK;
+	}
+	iowrite32(ctrl, demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+        printk("pds03_mmsensordev_enabling_store called\n");
+	return count;
+}
+static DEVICE_ATTR_RW(pds03_mmsensor_enabling);
+static ssize_t pds03_mmsensor_enabling_interrupt_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 enabling_component_int_pds03 = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	enabling_component_int_pds03 &= PDS03_MMSENSOR_CTRL_IEN_MASK;
+        printk("pds03_mmsensordev_enabling_interrupt_show called\n");
+	return sprintf(buf, "%d\n", !!enabling_component_int_pds03);
+}
+static ssize_t pds03_mmsensor_enabling_interrupt_store(struct device *child, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 ctrl = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	int enabling_component_int_pds03;
+	sscanf(buf, "%d", &enabling_component_int_pds03);
+	if (!enabling_component_int_pds03) {
+		ctrl &= ~PDS03_MMSENSOR_CTRL_IEN_MASK;
+	} else {
+		ctrl |= PDS03_MMSENSOR_CTRL_IEN_MASK;
+	}
+	iowrite32(ctrl, demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+        printk("pds03_mmsensordev_enabling_interrupt_store called\n");
+	return count;
+}
+static DEVICE_ATTR_RW(pds03_mmsensor_enabling_interrupt);
+static ssize_t pds03_mmsensor_data_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 data = ioread32(demodev->base_addr + PDS03_MMSENSOR_DATA_OFFSET);
+	data &= PDS03_MMSENSOR_DATA_MASK;
+        printk("pds03_mmsensordev_data_show called\n");
+        printk("data %x ", data);
+	
+	return sprintf(buf, "%d\n", pds_03_to_mV(data));
+}
+static DEVICE_ATTR_RO(pds03_mmsensor_data);
+static ssize_t pds03_mmsensor_resolution_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 ctrl = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	ctrl &= PDS03_MMSENSOR_CTRL_RES_MASK;
+        printk("pds03_mmsensordev_resolution_show called\n");
+	if (ctrl == PDS03_12BIT_RESOLUTION_CTRL) {
+        	printk("FINE\n");
+		return sprintf(buf,"fine\n");
+	} else if (ctrl == PDS03_8BIT_RESOLUTION_CTRL) {
+        	printk("COARSE\n");
+		return sprintf(buf,"coarse\n");
+	}
+	return -EINVAL;
+}
+static ssize_t pds03_mmsensor_resolution_store(struct device *child, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 ctrl = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	// Reset control register
+	ctrl &= ~PDS03_MMSENSOR_CTRL_RES_MASK;
+	if(strcmp(buf,"fine\n") == 0) {
+		ctrl |= PDS03_12BIT_RESOLUTION_CTRL;
+	} else if(strcmp(buf,"coarse\n") == 0) {
+		ctrl |= PDS03_8BIT_RESOLUTION_CTRL;
+	} else {
+		pr_alert("Bad command for resolution\n");
+		return -EINVAL;
+	}
+	iowrite32(ctrl, demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+        printk("pds03_mmsensordev_resolution_store called\n");
+	return count;
+}
+static DEVICE_ATTR_RW(pds03_mmsensor_resolution);
+static ssize_t pds03_mmsensor_available_resolution_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	ssize_t i = 0;
+	
+	i += sprintf(buf,"fine, coarse\n");
+        printk("pds03_mmsensordev_available_resolution_show called\n");
+	return i;
+}
+static DEVICE_ATTR_RO(pds03_mmsensor_available_resolution);
+static ssize_t pds03_mmsensor_frequency_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 ctrl = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	ctrl &= PDS03_MMSENSOR_CTRL_FREQ_MASK;
+        printk("pds03_mmsensordev_frequency_show called\n");
+	if (ctrl == PDS03_NORMAL_FREQUENCY_CTRL) {
+        	printk("NORMAL\n");
+		return sprintf(buf,"normal\n");
+	} else if (ctrl == PDS03_FAST_FREQUENCY_CTRL) {
+        	printk("FAST\n");
+		return sprintf(buf,"fast\n");
+	}
+	return -EINVAL;
+}
+static ssize_t pds03_mmsensor_frequency_store(struct device *child, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct pds03_mmsensor *demodev = dev_get_drvdata(child);
+	u32 ctrl = ioread32(demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+	// Reset control register
+	ctrl &= ~PDS03_MMSENSOR_CTRL_FREQ_MASK;
+	printk(buf);
+	if(strcmp(buf,"normal\n") == 0) {
+		ctrl |= PDS03_NORMAL_FREQUENCY_CTRL;
+	} else if(strcmp(buf,"fast\n") == 0) {
+		ctrl |= PDS03_FAST_FREQUENCY_CTRL;
+	} else {
+		pr_alert("Bad command for frequency\n");
+		return -EINVAL;
+	}
+	iowrite32(ctrl, demodev->base_addr + PDS03_MMSENSOR_CTRL_OFFSET);
+        printk("pds03_mmsensordev_frequency_store called\n");
+	return count;
+}
+static DEVICE_ATTR_RW(pds03_mmsensor_frequency);
+static ssize_t pds03_mmsensor_available_frequency_show(struct device *child, struct device_attribute *attr, char *buf)
+{
+	ssize_t i = 0;
+	
+	i += sprintf(buf,"normal, fast\n");
+        printk("pds03_mmsensordev_available_frequency_show called\n");
+	return i;
+}
+static DEVICE_ATTR_RO(pds03_mmsensor_available_frequency);
+static struct attribute *pds03_mmsensor_attrs[] = {
+	&dev_attr_pds03_mmsensor_enabling.attr,
+	&dev_attr_pds03_mmsensor_enabling_interrupt.attr,
+	&dev_attr_pds03_mmsensor_data.attr,
+	&dev_attr_pds03_mmsensor_resolution.attr,
+	&dev_attr_pds03_mmsensor_available_resolution.attr,
+	&dev_attr_pds03_mmsensor_frequency.attr,
+	&dev_attr_pds03_mmsensor_available_frequency.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(pds03_mmsensor);
+static irqreturn_t pds03_mmsensor_isr(int irq, void *data)
+{
+	struct pds03_mmsensor *demodev = data;
+	sysfs_notify(&demodev->dev->kobj, NULL, "pds03_mmsensor_data");
+	pr_info("PDS03 MMSENSOR ISR\n");
+	iowrite32(0, demodev->base_addr + PDS03_MMSENSOR_STATUS_OFFSET);
+        printk("pds03_mmsensordev_isr called\n");
+	
+	return IRQ_HANDLED;
+}
+static const struct of_device_id pds03_mmsensor_of_match[] = {
+	{ .compatible = "pds03,mmsensor", },
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, pds03_mmsensor_of_match);
+static int pds03_mmsensordev_setup(struct device *parent)
+{
+	int ret;
+	dev_t devt;
+	struct pds03_mmsensor *demodev;
+	demodev = dev_get_drvdata(parent);
+	ret = alloc_chrdev_region(&devt, 0, 1, PDS03_DEVICE_FILE_NAME);
+	if (ret < 0) {
+		dev_err(parent, "failed: alloc_chrdev_region\n");
+		goto fail_alloc_chrdev_region;
+	}
+	demodev->devt = devt;
+	cdev_init(&demodev->cdev, &pds03_mmsensordev_fops);
+	ret = cdev_add(&demodev->cdev, devt, 1);
+	if (ret < 0) {
+		dev_err(parent, "failed: cdev_init\n");
+		goto fail_add_cdev;
+	}
+	pds03_mmsensor_class = class_create(THIS_MODULE, "pds03");
+	if (!pds03_mmsensor_class) {
+		ret = -EEXIST;
+		dev_err(parent, "failed: create_class\n");
+		goto fail_create_class;
+	}
+	demodev->dev = device_create_with_groups(pds03_mmsensor_class, parent, devt, demodev, pds03_mmsensor_groups, "%s%d", PDS03_DEVICE_FILE_NAME, MINOR(devt));
+	if (IS_ERR(demodev->dev)) {
+		demodev->dev = NULL;
+		ret = -EINVAL;
+		dev_err(parent, "failed: create_device\n");
+		goto fail_create_device;
+	}
+        printk("pds03_mmsensordev_setup called\n");
+	return 0;
+	fail_create_device:
+		class_destroy(pds03_mmsensor_class);
+	fail_create_class:
+		cdev_del(&demodev->cdev);
+	fail_add_cdev:
+		unregister_chrdev_region(devt, 1);
+	fail_alloc_chrdev_region:
+		return ret;
+}
+static int pds03_mmsensor_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct pds03_mmsensor *demodev;
+	struct resource *res;
+	const struct of_device_id *match;
+	demodev = devm_kzalloc(&pdev->dev, sizeof(*demodev), GFP_KERNEL);
+	if (!demodev)
+		return -ENOMEM;
+	demodev->parent = &pdev->dev;
+	match = of_match_node(pds03_mmsensor_of_match, pdev->dev.of_node);
+	if (!match) {
+		dev_err(&pdev->dev, "of_match_node() failed\n");
+		return -EINVAL;
+	}
+	platform_set_drvdata(pdev, demodev);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	demodev->base_addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(demodev->base_addr)) 
+		return PTR_ERR(demodev->base_addr);
+	demodev->irq = platform_get_irq(pdev, 0);
+	if (demodev->irq < 0) {
+		dev_err(&pdev->dev, "invalid IRQ\n");
+		return demodev->irq;
+	}
+	ret = devm_request_irq(&pdev->dev, demodev->irq, pds03_mmsensor_isr, 0, dev_name(&pdev->dev), demodev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to request IRQ\n");
+		return ret;
+	}
+	/* initialize device */
+	ret = pds03_mmsensordev_setup(&pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to create device\n");
+		return ret;
+	}
+        printk("pds03_mmsensor_probe called\n");
+	return 0;
+}
+static int pds03_mmsensor_remove(struct platform_device *pdev)
+{
+	struct pds03_mmsensor *demodev;
+	demodev = dev_get_drvdata(&pdev->dev);
+	device_destroy(pds03_mmsensor_class, demodev->devt);
+	class_destroy(pds03_mmsensor_class);
+	cdev_del(&demodev->cdev);
+	unregister_chrdev_region(demodev->devt, 1);
+	printk("pds03_mmsensor_remove called\n");
+	
+	return 0;
+}
+static struct platform_driver pds03_mmsensor_driver = {
+	.driver = {
+		.name = PDS03_DRIVER_NAME,
+		.of_match_table = pds03_mmsensor_of_match,
+	},
+	.probe = pds03_mmsensor_probe,
+	.remove = pds03_mmsensor_remove,
+};
+static int __init pds03_mmsensor_init(void)
+{
+	pr_alert("Init done\n");
+	return platform_driver_register(&pds03_mmsensor_driver);
+}
+static void __exit pds03_mmsensor_exit(void)
+{
+	pr_alert("Goodbye, world!\n");
+	return platform_driver_unregister(&pds03_mmsensor_driver);
+}
+module_init(pds03_mmsensor_init);
+module_exit(pds03_mmsensor_exit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PDS03 MMSENSOR Driver and Device");
+MODULE_AUTHOR("aleksandarv");
diff -ruN linux-5.0.2a/drivers/char/Kconfig linux-5.0.2b/drivers/char/Kconfig
--- linux-5.0.2a/drivers/char/Kconfig	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/drivers/char/Kconfig	2020-09-20 13:41:24.446882000 -0700
@@ -100,6 +100,13 @@
 	  If you have more than 8 printers, you need to increase the LP_NO
 	  macro in lp.c and the PARPORT_MAX macro in parport.h.
 
+config PDS03_MMSENSOR
+	tristate "PDS03 Memory Mapped Sensor driver"
+	depends on ARCH_VEXPRESS
+	default y
+	help
+	  This is driver for Memory Mapped Sensor project PDS03
+
 config LP_CONSOLE
 	bool "Support for console on line printer"
 	depends on PRINTER
diff -ruN linux-5.0.2a/drivers/char/Makefile linux-5.0.2b/drivers/char/Makefile
--- linux-5.0.2a/drivers/char/Makefile	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/drivers/char/Makefile	2020-09-18 08:29:31.775836000 -0700
@@ -3,6 +3,7 @@
 # Makefile for the kernel character device drivers.
 #
 
+obj-$(CONFIG_PDS03_MMSENSOR)	+= etf-pds-03.o
 obj-y				+= mem.o random.o
 obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
 obj-y				+= misc.o
diff -ruN linux-5.0.2a/.get_maintainer.ignore linux-5.0.2b/.get_maintainer.ignore
--- linux-5.0.2a/.get_maintainer.ignore	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/.get_maintainer.ignore	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-Christoph Hellwig <hch@lst.de>
diff -ruN linux-5.0.2a/.gitattributes linux-5.0.2b/.gitattributes
--- linux-5.0.2a/.gitattributes	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/.gitattributes	1969-12-31 16:00:00.000000000 -0800
@@ -1,2 +0,0 @@
-*.c   diff=cpp
-*.h   diff=cpp
diff -ruN linux-5.0.2a/.gitignore linux-5.0.2b/.gitignore
--- linux-5.0.2a/.gitignore	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/.gitignore	1969-12-31 16:00:00.000000000 -0800
@@ -1,135 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# NOTE! Please use 'git ls-files -i --exclude-standard'
-# command after changing this file, to see if there are
-# any tracked files which get ignored after the change.
-#
-# Normal rules (sorted alphabetically)
-#
-.*
-*.a
-*.asn1.[ch]
-*.bin
-*.bz2
-*.c.[012]*.*
-*.dt.yaml
-*.dtb
-*.dtb.S
-*.dwo
-*.elf
-*.gcno
-*.gz
-*.i
-*.ko
-*.lex.c
-*.ll
-*.lst
-*.lz4
-*.lzma
-*.lzo
-*.mod.c
-*.o
-*.o.*
-*.order
-*.patch
-*.s
-*.so
-*.so.dbg
-*.su
-*.symtypes
-*.tab.[ch]
-*.tar
-*.xz
-Module.symvers
-modules.builtin
-
-#
-# Top-level generic files
-#
-/tags
-/TAGS
-/linux
-/vmlinux
-/vmlinux.32
-/vmlinux-gdb.py
-/vmlinuz
-/System.map
-/Module.markers
-
-#
-# RPM spec file (make rpm-pkg)
-#
-/*.spec
-
-#
-# Debian directory (make deb-pkg)
-#
-/debian/
-
-#
-# Snap directory (make snap-pkg)
-#
-/snap/
-
-#
-# tar directory (make tar*-pkg)
-#
-/tar-install/
-
-#
-# git files that we don't want to ignore even if they are dot-files
-#
-!.gitignore
-!.mailmap
-!.cocciconfig
-!.clang-format
-
-#
-# Generated include files
-#
-include/config
-include/generated
-include/ksym
-arch/*/include/generated
-
-# stgit generated dirs
-patches-*
-
-# quilt's files
-patches
-series
-
-# cscope files
-cscope.*
-ncscope.*
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-# id-utils files
-ID
-
-*.orig
-*~
-\#*#
-
-#
-# Leavings from module signing
-#
-extra_certificates
-signing_key.pem
-signing_key.priv
-signing_key.x509
-x509.genkey
-
-# Kconfig presets
-all.config
-
-# Kdevelop4
-*.kdev4
diff -ruN linux-5.0.2a/.mailmap linux-5.0.2b/.mailmap
--- linux-5.0.2a/.mailmap	2019-03-13 14:01:32.000000000 -0700
+++ linux-5.0.2b/.mailmap	1969-12-31 16:00:00.000000000 -0800
@@ -1,225 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# repo-abbrev: /pub/scm/linux/kernel/git/
-#
-
-Aaron Durbin <adurbin@google.com>
-Adam Oldham <oldhamca@gmail.com>
-Adam Radford <aradford@gmail.com>
-Adrian Bunk <bunk@stusta.de>
-Adriana Reus <adi.reus@gmail.com> <adriana.reus@intel.com>
-Alan Cox <alan@lxorguk.ukuu.org.uk>
-Alan Cox <root@hraefn.swansea.linux.org.uk>
-Aleksey Gorelov <aleksey_gorelov@phoenix.com>
-Aleksandar Markovic <aleksandar.markovic@mips.com> <aleksandar.markovic@imgtec.com>
-Al Viro <viro@ftp.linux.org.uk>
-Al Viro <viro@zenIV.linux.org.uk>
-Andi Shyti <andi@etezian.org> <andi.shyti@samsung.com>
-Andreas Herrmann <aherrman@de.ibm.com>
-Andrey Ryabinin <ryabinin.a.a@gmail.com> <a.ryabinin@samsung.com>
-Andrew Morton <akpm@linux-foundation.org>
-Andrew Vasquez <andrew.vasquez@qlogic.com>
-Andy Adamson <andros@citi.umich.edu>
-Antoine Tenart <antoine.tenart@free-electrons.com>
-Antonio Ospite <ao2@ao2.it> <ao2@amarulasolutions.com>
-Archit Taneja <archit@ti.com>
-Arnaud Patard <arnaud.patard@rtp-net.org>
-Arnd Bergmann <arnd@arndb.de>
-Axel Dyks <xl@xlsigned.net>
-Axel Lin <axel.lin@gmail.com>
-Bart Van Assche <bvanassche@acm.org> <bart.vanassche@wdc.com>
-Bart Van Assche <bvanassche@acm.org> <bart.vanassche@sandisk.com>
-Ben Gardner <bgardner@wabtec.com>
-Ben M Cahill <ben.m.cahill@intel.com>
-Björn Steinbrink <B.Steinbrink@gmx.de>
-Boris Brezillon <bbrezillon@kernel.org> <boris.brezillon@bootlin.com>
-Boris Brezillon <bbrezillon@kernel.org> <boris.brezillon@free-electrons.com>
-Boris Brezillon <bbrezillon@kernel.org> <b.brezillon.dev@gmail.com>
-Boris Brezillon <bbrezillon@kernel.org> <b.brezillon@overkiz.com>
-Brian Avery <b.avery@hp.com>
-Brian King <brking@us.ibm.com>
-Christoph Hellwig <hch@lst.de>
-Christophe Ricard <christophe.ricard@gmail.com>
-Corey Minyard <minyard@acm.org>
-Damian Hobson-Garcia <dhobsong@igel.co.jp>
-David Brownell <david-b@pacbell.net>
-David Woodhouse <dwmw2@shinybook.infradead.org>
-Dengcheng Zhu <dzhu@wavecomp.com> <dengcheng.zhu@mips.com>
-Dengcheng Zhu <dzhu@wavecomp.com> <dengcheng.zhu@imgtec.com>
-Dengcheng Zhu <dzhu@wavecomp.com> <dczhu@mips.com>
-Dengcheng Zhu <dzhu@wavecomp.com> <dengcheng.zhu@gmail.com>
-Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
-Domen Puncer <domen@coderock.org>
-Douglas Gilbert <dougg@torque.net>
-Ed L. Cashin <ecashin@coraid.com>
-Evgeniy Polyakov <johnpol@2ka.mipt.ru>
-Felipe W Damasio <felipewd@terra.com.br>
-Felix Kuhling <fxkuehl@gmx.de>
-Felix Moeller <felix@derklecks.de>
-Filipe Lautert <filipe@icewall.org>
-Franck Bui-Huu <vagabon.xyz@gmail.com>
-Frank Rowand <frowand.list@gmail.com> <frowand@mvista.com>
-Frank Rowand <frowand.list@gmail.com> <frank.rowand@am.sony.com>
-Frank Rowand <frowand.list@gmail.com> <frank.rowand@sonymobile.com>
-Frank Zago <fzago@systemfabricworks.com>
-Greg Kroah-Hartman <greg@echidna.(none)>
-Greg Kroah-Hartman <gregkh@suse.de>
-Greg Kroah-Hartman <greg@kroah.com>
-Gregory CLEMENT <gregory.clement@bootlin.com> <gregory.clement@free-electrons.com>
-Henk Vergonet <Henk.Vergonet@gmail.com>
-Henrik Kretzschmar <henne@nachtwindheim.de>
-Henrik Rydberg <rydberg@bitmath.org>
-Herbert Xu <herbert@gondor.apana.org.au>
-Jacob Shin <Jacob.Shin@amd.com>
-James Bottomley <jejb@mulgrave.(none)>
-James Bottomley <jejb@titanic.il.steeleye.com>
-James E Wilson <wilson@specifix.com>
-James Hogan <jhogan@kernel.org> <james.hogan@imgtec.com>
-James Hogan <jhogan@kernel.org> <james@albanarts.com>
-James Ketrenos <jketreno@io.(none)>
-Jason Gunthorpe <jgg@ziepe.ca> <jgg@mellanox.com>
-Jason Gunthorpe <jgg@ziepe.ca> <jgunthorpe@obsidianresearch.com>
-Javi Merino <javi.merino@kernel.org> <javi.merino@arm.com>
-<javier@osg.samsung.com> <javier.martinez@collabora.co.uk>
-Jean Tourrilhes <jt@hpl.hp.com>
-Jeff Garzik <jgarzik@pretzel.yyz.us>
-Jeff Layton <jlayton@kernel.org> <jlayton@redhat.com>
-Jeff Layton <jlayton@kernel.org> <jlayton@poochiereds.net>
-Jeff Layton <jlayton@kernel.org> <jlayton@primarydata.com>
-Jens Axboe <axboe@suse.de>
-Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
-Johan Hovold <johan@kernel.org> <jhovold@gmail.com>
-Johan Hovold <johan@kernel.org> <johan@hovoldconsulting.com>
-John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de>
-John Stultz <johnstul@us.ibm.com>
-<josh@joshtriplett.org> <josh@freedesktop.org>
-<josh@joshtriplett.org> <josh@kernel.org>
-<josh@joshtriplett.org> <josht@linux.vnet.ibm.com>
-<josh@joshtriplett.org> <josht@us.ibm.com>
-<josh@joshtriplett.org> <josht@vnet.ibm.com>
-Juha Yrjola <at solidboot.com>
-Juha Yrjola <juha.yrjola@nokia.com>
-Juha Yrjola <juha.yrjola@solidboot.com>
-Kay Sievers <kay.sievers@vrfy.org>
-Kenneth W Chen <kenneth.w.chen@intel.com>
-Konstantin Khlebnikov <koct9i@gmail.com> <k.khlebnikov@samsung.com>
-Koushik <raghavendra.koushik@neterion.com>
-Krzysztof Kozlowski <krzk@kernel.org> <k.kozlowski@samsung.com>
-Krzysztof Kozlowski <krzk@kernel.org> <k.kozlowski.k@gmail.com>
-Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
-Leon Romanovsky <leon@kernel.org> <leon@leon.nu>
-Leon Romanovsky <leon@kernel.org> <leonro@mellanox.com>
-Leonid I Ananiev <leonid.i.ananiev@intel.com>
-Linas Vepstas <linas@austin.ibm.com>
-Linus Lüssing <linus.luessing@c0d3.blue> <linus.luessing@web.de>
-Linus Lüssing <linus.luessing@c0d3.blue> <linus.luessing@ascom.ch>
-Maciej W. Rozycki <macro@mips.com> <macro@imgtec.com>
-Marcin Nowakowski <marcin.nowakowski@mips.com> <marcin.nowakowski@imgtec.com>
-Mark Brown <broonie@sirena.org.uk>
-Mark Yao <markyao0591@gmail.com> <mark.yao@rock-chips.com>
-Martin Kepplinger <martink@posteo.de> <martin.kepplinger@theobroma-systems.com>
-Martin Kepplinger <martink@posteo.de> <martin.kepplinger@ginzinger.com>
-Matthew Wilcox <willy@infradead.org> <matthew.r.wilcox@intel.com>
-Matthew Wilcox <willy@infradead.org> <matthew@wil.cx>
-Matthew Wilcox <willy@infradead.org> <mawilcox@linuxonhyperv.com>
-Matthew Wilcox <willy@infradead.org> <mawilcox@microsoft.com>
-Matthew Wilcox <willy@infradead.org> <willy@debian.org>
-Matthew Wilcox <willy@infradead.org> <willy@linux.intel.com>
-Matthew Wilcox <willy@infradead.org> <willy@parisc-linux.org>
-Matthieu CASTET <castet.matthieu@free.fr>
-Mauro Carvalho Chehab <mchehab@kernel.org> <mchehab@brturbo.com.br>
-Mauro Carvalho Chehab <mchehab@kernel.org> <maurochehab@gmail.com>
-Mauro Carvalho Chehab <mchehab@kernel.org> <mchehab@infradead.org>
-Mauro Carvalho Chehab <mchehab@kernel.org> <mchehab@redhat.com>
-Mauro Carvalho Chehab <mchehab@kernel.org> <m.chehab@samsung.com>
-Mauro Carvalho Chehab <mchehab@kernel.org> <mchehab@osg.samsung.com>
-Mauro Carvalho Chehab <mchehab@kernel.org> <mchehab@s-opensource.com>
-Matt Ranostay <mranostay@gmail.com> Matthew Ranostay <mranostay@embeddedalley.com>
-Matt Ranostay <mranostay@gmail.com> <matt.ranostay@intel.com>
-Matt Ranostay <matt.ranostay@konsulko.com> <matt@ranostay.consulting>
-Matt Redfearn <matt.redfearn@mips.com> <matt.redfearn@imgtec.com>
-Mayuresh Janorkar <mayur@ti.com>
-Michael Buesch <m@bues.ch>
-Michel Dänzer <michel@tungstengraphics.com>
-Miodrag Dinic <miodrag.dinic@mips.com> <miodrag.dinic@imgtec.com>
-Miquel Raynal <miquel.raynal@bootlin.com> <miquel.raynal@free-electrons.com>
-Mitesh shah <mshah@teja.com>
-Mohit Kumar <mohit.kumar@st.com> <mohit.kumar.dhaka@gmail.com>
-Morten Welinder <terra@gnome.org>
-Morten Welinder <welinder@anemone.rentec.com>
-Morten Welinder <welinder@darter.rentec.com>
-Morten Welinder <welinder@troll.com>
-Mythri P K <mythripk@ti.com>
-Nguyen Anh Quynh <aquynh@gmail.com>
-Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
-Patrick Mochel <mochel@digitalimplant.org>
-Paul Burton <paul.burton@mips.com> <paul.burton@imgtec.com>
-Peter A Jonsson <pj@ludd.ltu.se>
-Peter Oruba <peter@oruba.de>
-Peter Oruba <peter.oruba@amd.com>
-Pratyush Anand <pratyush.anand@gmail.com> <pratyush.anand@st.com>
-Praveen BP <praveenbp@ti.com>
-Punit Agrawal <punitagrawal@gmail.com> <punit.agrawal@arm.com>
-Qais Yousef <qsyousef@gmail.com> <qais.yousef@imgtec.com>
-Oleksij Rempel <linux@rempel-privat.de> <bug-track@fisher-privat.net>
-Oleksij Rempel <linux@rempel-privat.de> <external.Oleksij.Rempel@de.bosch.com>
-Oleksij Rempel <linux@rempel-privat.de> <fixed-term.Oleksij.Rempel@de.bosch.com>
-Oleksij Rempel <linux@rempel-privat.de> <o.rempel@pengutronix.de>
-Oleksij Rempel <linux@rempel-privat.de> <ore@pengutronix.de>
-Rajesh Shah <rajesh.shah@intel.com>
-Ralf Baechle <ralf@linux-mips.org>
-Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
-Randy Dunlap <rdunlap@infradead.org> <rdunlap@xenotime.net>
-Rémi Denis-Courmont <rdenis@simphalempin.com>
-Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
-Ross Zwisler <zwisler@kernel.org> <ross.zwisler@linux.intel.com>
-Rudolf Marek <R.Marek@sh.cvut.cz>
-Rui Saraiva <rmps@joel.ist.utl.pt>
-Sachin P Sant <ssant@in.ibm.com>
-Sarangdhar Joshi <spjoshi@codeaurora.org>
-Sam Ravnborg <sam@mars.ravnborg.org>
-Santosh Shilimkar <ssantosh@kernel.org>
-Santosh Shilimkar <santosh.shilimkar@oracle.org>
-Sascha Hauer <s.hauer@pengutronix.de>
-S.Çağlar Onur <caglar@pardus.org.tr>
-Sebastian Reichel <sre@kernel.org> <sre@debian.org>
-Sebastian Reichel <sre@kernel.org> <sebastian.reichel@collabora.co.uk>
-Shiraz Hashim <shiraz.linux.kernel@gmail.com> <shiraz.hashim@st.com>
-Shuah Khan <shuah@kernel.org> <shuahkhan@gmail.com>
-Shuah Khan <shuah@kernel.org> <shuah.khan@hp.com>
-Shuah Khan <shuah@kernel.org> <shuahkh@osg.samsung.com>
-Shuah Khan <shuah@kernel.org> <shuah.kh@samsung.com>
-Simon Kelley <simon@thekelleys.org.uk>
-Stéphane Witzmann <stephane.witzmann@ubpmes.univ-bpclermont.fr>
-Stephen Hemminger <shemminger@osdl.org>
-Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
-Subhash Jadavani <subhashj@codeaurora.org>
-Sudeep Holla <sudeep.holla@arm.com> Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
-Sumit Semwal <sumit.semwal@ti.com>
-Tejun Heo <htejun@gmail.com>
-Thomas Graf <tgraf@suug.ch>
-Thomas Pedersen <twp@codeaurora.org>
-Tony Luck <tony.luck@intel.com>
-Tsuneo Yoshioka <Tsuneo.Yoshioka@f-secure.com>
-Uwe Kleine-König <ukleinek@informatik.uni-freiburg.de>
-Uwe Kleine-König <ukl@pengutronix.de>
-Uwe Kleine-König <Uwe.Kleine-Koenig@digi.com>
-Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
-Vinod Koul <vkoul@kernel.org> <vinod.koul@intel.com>
-Vinod Koul <vkoul@kernel.org> <vinod.koul@linux.intel.com>
-Vinod Koul <vkoul@kernel.org> <vkoul@infradead.org>
-Viresh Kumar <vireshk@kernel.org> <viresh.kumar@st.com>
-Viresh Kumar <vireshk@kernel.org> <viresh.linux@gmail.com>
-Viresh Kumar <vireshk@kernel.org> <viresh.kumar2@arm.com>
-Vlad Dogaru <ddvlad@gmail.com> <vlad.dogaru@intel.com>
-Vladimir Davydov <vdavydov.dev@gmail.com> <vdavydov@virtuozzo.com>
-Vladimir Davydov <vdavydov.dev@gmail.com> <vdavydov@parallels.com>
-Takashi YOSHII <takashi.yoshii.zj@renesas.com>
-Yakir Yang <kuankuan.y@gmail.com> <ykk@rock-chips.com>
-Yusuke Goda <goda.yusuke@renesas.com>
-Gustavo Padovan <gustavo@las.ic.unicamp.br>
-Gustavo Padovan <padovan@profusion.mobi>
